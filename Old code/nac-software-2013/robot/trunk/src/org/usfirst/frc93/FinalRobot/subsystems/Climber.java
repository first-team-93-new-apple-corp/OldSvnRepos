// RobotBuilder Version: 0.0.2
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in th future.
package org.usfirst.frc93.FinalRobot.subsystems;

import edu.wpi.first.wpilibj.*;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import org.usfirst.frc93.FinalRobot.CoordinatedPIDProfiler;
import org.usfirst.frc93.FinalRobot.Robot;
import org.usfirst.frc93.FinalRobot.RobotMap;
import org.usfirst.frc93.FinalRobot.commands.ManualClimb;

/**
 *
 */
public class Climber extends Subsystem {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    Compressor compressor = RobotMap.compressor;
    DoubleSolenoid tiltSolenoid = RobotMap.tiltSolenoid;
    DoubleSolenoid gripperSolenoid = RobotMap.blockerSolenoid;
    DoubleSolenoid lockSolenoid = RobotMap.lockSolenoid;
    CoordinatedPIDProfiler profiler = RobotMap.climberController;
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    Timer m_tiltTimer = new Timer();
    Timer m_gripperTimer = new Timer();
    // Put methods for controlling this subsystem
    // here. Call these from Commands.
    boolean aligned = false;

    public boolean isAligned() {
        return aligned;
    }

    public void setAligned() {
        aligned = true;
    }

    public void resetAligned() {
        aligned = false;
    }
    boolean raiseLatch = false;

    public boolean raiseSlider(int setpointUp) {
        if (!raiseLatch) {
            profiler.reset();
            profiler.enable();
            profiler.setSetpoint(setpointUp);
            raiseLatch = true;
        }
        boolean done = (profiler.calculate());
        if (done) {
            raiseLatch = false;
            profiler.disable();
            return true;
        }
        return false;
    }
    boolean pullDownLatch = false;

    public boolean pullDownSlider(int setpointDown) {
        if (!pullDownLatch) {
            profiler.reset();
            profiler.setSetpoint(setpointDown);
            profiler.enable();
            pullDownLatch = true;
        }
        boolean done = (profiler.calculate());
        if (done) {
            profiler.disable();
            pullDownLatch = false;
            return true;
        }
        return false;
    }
    boolean timerLatch = false;

    public boolean tilt() {
        tiltSolenoid.set(DoubleSolenoid.Value.kForward);
        if (timerLatch == false) {
            m_tiltTimer.start();
            timerLatch = true;
        }
        if (m_tiltTimer.get() >= 1) {
            m_tiltTimer.stop();
            timerLatch = false;
            return true;
        } else {
            return false;
        }
    }
    boolean hookLatch = false;
    /*
     public boolean hook(){
     if(hookLatch == false){
     if(raiseSlider() == true){
     hookLatch = true;
     }
     }   
     else if(hookLatch == true){
     if(pullDownSlider() == true){
     hookLatch = false;
     return true;
     }   
     }
     return false;
     }
    
     * 
     */

    public boolean gripperRelease() {
        gripperSolenoid.set(DoubleSolenoid.Value.kForward);
        if (timerLatch == false) {
            m_gripperTimer.start();
            timerLatch = true;
        }
        if (m_gripperTimer.get() >= 1) {
            m_gripperTimer.stop();
            timerLatch = false;
            return true;
        } else {
            return false;
        }
    }

    public boolean gripperLock() {
        gripperSolenoid.set(DoubleSolenoid.Value.kReverse);
        if (timerLatch == false) {
            m_gripperTimer.start();
            timerLatch = true;
        }
        if (m_gripperTimer.get() >= 1) {
            m_gripperTimer.stop();
            timerLatch = false;
            return true;
        } else {
            return false;
        }
    }

    public boolean mechanicalLock() {
        lockSolenoid.set(DoubleSolenoid.Value.kForward);
        if (timerLatch == false) {
            m_tiltTimer.start();
            timerLatch = true;
        }
        if (m_tiltTimer.get() >= 1) {
            m_tiltTimer.stop();
            timerLatch = false;
            return true;
        } else {
            return false;
        }
    }

    public boolean mechanicalRelease() {
        lockSolenoid.set(DoubleSolenoid.Value.kReverse);
        if (timerLatch == false) {
            m_tiltTimer.start();
            timerLatch = true;
        }
        if (m_tiltTimer.get() >= 1) {
            m_tiltTimer.stop();
            timerLatch = false;
            return true;
        } else {
            return false;
        }
    }

    public boolean retractTilt() {
        tiltSolenoid.set(DoubleSolenoid.Value.kReverse);
        if (timerLatch == false) {
            m_tiltTimer.start();
            timerLatch = true;
        }
        if (m_tiltTimer.get() >= 1) {
            m_tiltTimer.stop();
            timerLatch = false;
            return true;
        } else {
            return false;
        }
    }
    double tolerance = 0.15f;

    public void manualOverride() {
        profiler.disable();
        double driveValLeft = Robot.oi.getOperator().getRawAxis(2);
        double driveValRight = Robot.oi.getOperator().getRawAxis(4);
        driveValLeft = (Math.abs(driveValLeft) > tolerance) ? -driveValLeft : 0;
        driveValRight = (Math.abs(driveValRight) > tolerance) ? -driveValRight : 0;
        RobotMap.climberLeftMotor.set(driveValLeft);
        RobotMap.climberRightMotor.set(driveValRight);
        int raiseHeight = 1050;
        SmartDashboard.putNumber("Left Climber Position", RobotMap.climberLeftEnc.getDistance());
        SmartDashboard.putNumber("Right Climber Position",RobotMap.climberRightEnc.getDistance());
        SmartDashboard.putBoolean("Climber High Enough?", (RobotMap.climberLeftEnc.getDistance()>raiseHeight && RobotMap.climberRightEnc.getDistance()>raiseHeight));
        
    }

    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
        // Set the default command for a subsystem here.
        setDefaultCommand(new ManualClimb());
    }
}
