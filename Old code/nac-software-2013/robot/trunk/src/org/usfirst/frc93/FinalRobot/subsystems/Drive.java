// RobotBuilder Version: 0.0.2
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in th future.
package org.usfirst.frc93.FinalRobot.subsystems;
import org.usfirst.frc93.FinalRobot.RobotMap;
import edu.wpi.first.wpilibj.*;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.livewindow.LiveWindow;
import edu.wpi.first.wpilibj.networktables2.TableKeyExistsWithDifferentTypeException;
import edu.wpi.first.wpilibj.smartdashboard.SendableChooser;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import org.usfirst.frc93.FinalRobot.Robot;
import org.usfirst.frc93.FinalRobot.commands.SwitchMecanumDriveCommand;
/**
 *
 */
public class Drive extends Subsystem {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    SpeedController frontRight = RobotMap.driveFrontRight;
    SpeedController frontLeft = RobotMap.driveFrontLeft;
    SpeedController backRight = RobotMap.driveBackRight;
    SpeedController backLeft = RobotMap.driveBackLeft;
    RobotDrive robotDrive = RobotMap.driveRobotDrive;
    Encoder encoder = RobotMap.driveEncoder;
    Gyro gyro = RobotMap.driveGyro;
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    public Drive(){
        super();
        SmartDashboard.putData("Drive",this);
    }
    // Put methods for controlling this subsystem
    // here. Call these from Commands.
    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
        setDefaultCommand(new SwitchMecanumDriveCommand());
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
        // Set the default command for a subsystem here.
        //setDefaultCommand(new MySpecialCommand());
    }
    private double tolerance = 0.1f;
    private double rotMech = Preferences.getInstance().getDouble("rotmech", 1.0f);
    public void mecanumDrive(){
        double xAxis = Robot.oi.getDriver().getAxis(Joystick.AxisType.kX);
        double yAxis = Robot.oi.getDriver().getAxis(Joystick.AxisType.kY);
        double rotAxis = Robot.oi.getDriver().getRawAxis(4);
        //for(int i = 0; i<6; i++){
        //    System.out.println("Joystick Axis "+ i +" is at "+Robot.oi.getDriver().getRawAxis(i));
        //}
        xAxis = (Math.abs(xAxis) > tolerance) ? xAxis : 0;
        yAxis = (Math.abs(yAxis) > tolerance) ? yAxis : 0;
        rotAxis = (Math.abs(rotAxis) > tolerance) ? rotAxis : 0;
        if(swerveOnly){
            yAxis = 0;
            rotAxis = 0;
        }
        SmartDashboard.putBoolean("Am I swerving ? ",swerveOnly);
        updateDashboard();
        robotDrive.mecanumDrive_Cartesian(xAxis, yAxis, rotAxis*rotMech, 0);
    }
    private double rotTank = Preferences.getInstance().getDouble("rottank", 1.0f);
    public void tankDrive(){
        double leftMotors = Robot.oi.getDriver().getAxis(Joystick.AxisType.kY);
        double rightMotors = Robot.oi.getDriver().getAxis(Joystick.AxisType.kThrottle);
        leftMotors = (Math.abs(leftMotors)>tolerance) ? leftMotors : 0;
        rightMotors= (Math.abs(rightMotors)>tolerance) ? rightMotors : 0;
        robotDrive.tankDrive(leftMotors * (-1.0f)*rotTank, rightMotors*rotTank);
        updateDashboard();
    }
    public void updateDashboard(){
        double curAngle = RobotMap.driveGyro.getAngle() % 20.0f;    //Should be between 0 and 360
        SmartDashboard.putNumber("Gyro", Math.abs(curAngle));
        SmartDashboard.putBoolean("Drive ready to climb? ",(Math.abs(curAngle)>4.5 && Math.abs(curAngle)<5.0));
        SmartDashboard.putBoolean("Compressor running? ",!RobotMap.compressor.getPressureSwitchValue());
    }
    private boolean swerveOnly = false;
    public void swerveOnly(){
        swerveOnly = true;
    }
    public void resetGyro(){
        gyro.reset();
    }
    public void stopSwerveOnly(){
        swerveOnly = false;
    }
}
