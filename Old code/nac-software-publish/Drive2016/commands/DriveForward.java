// RobotBuilder Version: 1.5
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package org.usfirst.frc.team93.robot.commands;

import org.usfirst.frc.team93.robot.Robot;
import org.usfirst.frc.team93.robot.RobotMap;
import org.usfirst.frc.team93.robot.subsystems.Drive;

import edu.wpi.first.wpilibj.command.Command;

/**
 * This command has the robot drive forwards to a desired distance.
 * 
 * @author Admin93
 */

public class DriveForward extends Command
{
	private double m_driveDistance;
	private double m_maxError;
	double multiplierRight = .75;
	double multiplierLeft = .75;
	double time;
	// RATIO BETWEEN THESE MUST BE CONSTANT

	/**
	 * 
	 * @param driveDistance
	 *            How far to drive
	 * @param maxError
	 *            Acceptable range of this position
	 */
	public DriveForward(double driveDistance, double maxError)
	{
		m_driveDistance = driveDistance;
		m_maxError = maxError;

		// Use requires() here to declare subsystem dependencies
		requires(Robot.drive);
	}

	public DriveForward(double driveDistance, double maxError, double scalingFactor)
	{
		multiplierRight = scalingFactor;
		multiplierLeft = scalingFactor;

		m_driveDistance = driveDistance;
		m_maxError = maxError;

		// Use requires() here to declare subsystem dependencies
		requires(Robot.drive);
	}

	@Override
	/**
	 * This function sets the motors up to run to a certain distance
	 */

	protected void initialize()
	{
		Drive.resetSensors();
		time = 0;

		RobotMap.driveSpeedControl.reset();
		RobotMap.driveSteeringControl.reset();
		RobotMap.driveSpeedControl.enable();
		RobotMap.driveSteeringControl.enable();
		RobotMap.rightDriveGroup.setGains(RobotMap.speedA * multiplierRight, -RobotMap.speedA * multiplierRight,
				RobotMap.speedA * multiplierRight);
		RobotMap.leftDriveGroup.setGains(-RobotMap.speedB * multiplierLeft, RobotMap.speedB * multiplierLeft,
				-RobotMap.speedB * multiplierLeft);
		RobotMap.steerAndSpeed.setSteeringGain(1);
		// RobotMap.driveEncoderSteering.reset();
		// RobotMap.driveEncoderSteering.enable();
		// RobotMap.driveEncoderSteering.setSetpoint(0.0);
	}

	// Called repeatedly when this Command is scheduled to run
	@Override
	protected void execute()
	{
		RobotMap.driveSpeedControl.setSetpoint(m_driveDistance);
		RobotMap.driveSteeringControl.setSetpoint(0);
	}

	// Make this return true when this Command no longer needs to run execute()
	@Override
	protected boolean isFinished()
	{
		double currentError = Math.abs(RobotMap.driveSpeedControl.getError());
		// System.out.println("Drive Error " + currentError);
		if (currentError <= m_maxError)
		{
			time += .02;
		} else
		{
			time = 0;
		}
		if (currentError <= m_maxError && time >= 1)
		{
			return true;
		}
		return false;

	}

	// Called once after isFinished returns true
	@Override
	protected void end()
	{
		RobotMap.driveSpeedControl.disable();
		RobotMap.driveSteeringControl.disable();
		Drive.setAllMotors(0.0);
		RobotMap.rightDriveGroup.setGains(RobotMap.speedA, -RobotMap.speedA, RobotMap.speedA);
		RobotMap.leftDriveGroup.setGains(-RobotMap.speedB, RobotMap.speedB, -RobotMap.speedB);
	}

	// Called when another command which requires one or more of the same
	// subsystems is scheduled to run
	@Override
	protected void interrupted()
	{
		this.end();
	}
}